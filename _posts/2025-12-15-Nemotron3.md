---
layout: post
title: "Reading Note on Nvidia Nemotron 3"
date: 2025-12-15
categories: [Nemontron]
tags: [Nemontron]
---

Reading the following paper:
- [NVIDIA Nemotron 3: Efficient and Open Intelligence](https://research.nvidia.com/labs/nemotron/files/NVIDIA-Nemotron-3-White-Paper.pdf)
- [Nemotron 3 Nano: Open, Efficient Mixture-of-Experts Hybrid Mamba-Transformer Model for Agentic Reasoning](https://research.nvidia.com/labs/nemotron/files/NVIDIA-Nemotron-3-Nano-Technical-Report.pdf)
- [Nemotron-Cascade: Scaling Cascaded Reinforcement Learning for General-Purpose Reasoning Models](https://research.nvidia.com/labs/nemotron/files/Nemotron-Cascade.pdf)

# Nemotron 3

## 1. Architectural Backbone: Hybrid Mamba-MoE
The fundamental shift in Nemotron 3 is the deprecation of the standard Transformer backbone in favor of a **Hybrid Mamba-2 / Transformer** architecture.

### The Linear-State Mechanism
Standard Transformers suffer from linear memory growth regarding the Key-Value (KV) cache during generation. Nemotron 3 mitigates this by predominantly interleaving MoE layers with **Mamba-2 layers** rather than Self-Attention layers.
*   **Mamba-2 Layer:** Operates with a constant state size during generation, decoupling memory footprint from sequence length.
*   **Selective Attention:** A sparse number of Self-Attention layers are retained to perform high-fidelity "all-to-all" information routing, which remains a weakness of pure State Space Models (SSMs).
*   **Throughput Gain:** This design yields a $3.3\times$ throughput increase for the Nano 30B-A3B model compared to a standard Transformer MoE (e.g., Qwen3-30B).

## 2. LatentMoE: Dimensionality Reduction for Scaling
For the larger models (Super and Ultra), NVIDIA introduces **LatentMoE**. This addresses the specific bottlenecks of MoE deployment: memory bandwidth (in latency-bound regimes) and all-to-all communication overhead (in throughput-bound regimes).

### The Mathematical Transformation
In a standard MoE, the communication volume scales linearly with the hidden dimension $d$ and the number of active experts $K$. LatentMoE introduces a compression step:

1.  **Projection:** Input token embeddings are projected from hidden dimension $d$ to a latent dimension $\ell$, where $\ell < d$ (typically $\ell \approx d/4$).
2.  **Routing:** Expert routing and computation occur entirely within this latent space $\ell$.
3.  **Reinvestment:** The bandwidth and parameter savings are reinvested to scale the expert count.

If the compression factor is $r = d/\ell$, the architecture scales the total number of experts ($N$) and active experts ($K$) as follows:

$$ N' = N \cdot r $$

$$ K' = K \cdot r $$

### Impact
By increasing $N$ and $K$ by the factor $d/\ell$, the model increases its **nonlinear budget** and expert diversity without increasing the communication payload or memory bandwidth requirements per token. Empirical results show LatentMoE consistently outperforms standard MoE baselines on MMLU, Code, and Math benchmarks when matched for inference cost.

## 3. NVFP4 Quantization & Numerical Stability
Nemotron 3 Super and Ultra are trained natively in **NVFP4** (NVIDIA 4-bit Floating Point). Unlike simulation-based approaches, this utilizes native NVFP4 GEMMs for forward propagation (`fprop`), activation gradients (`dgrad`), and weight gradients (`wgrad`).

### The Stability Recipe
Aggressive quantization to 4-bit often destabilizes hybrid architectures. The white paper identifies specific sensitivity profiles:
*   **Mamba Sensitivity:** Mamba output projection layers exhibited "flush to zero" rates up to **40%** when quantized to NVFP4, leading to severe information loss.
*   **Mixed-Precision Safeguards:** To maintain stability, the following layers are held in higher precision (MXFP8 or BF16):
    1.  Mamba Output Projections.
    2.  Query-Key-Value (QKV) Projections.
    3.  Attention Output Projections.

### Loss Analysis
The relative loss gap between BF16 and NVFP4 training diminishes as model scale increases. For the larger MoE models (A8B), the validation loss difference stabilizes at $< 0.6\%$.

## 4. Multi-Token Prediction (MTP) & Speculative Decoding
The Super and Ultra models integrate an MTP module that predicts multiple future tokens simultaneously during training.

*   **Training Signal:** MTP forces the model to plan ahead, densifying the supervisory signal and improving reasoning capabilities (approx. 2.4% gain on benchmarks).
*   **Inference Acceleration:** The MTP module acts as a built-in drafter for speculative decoding. In ablations, the first two MTP-predicted tokens achieved a **97% acceptance rate**, allowing the system to verify multiple tokens per pass without the latency overhead of a separate draft model.

## 5. Post-Training: Multi-Environment RL
Post-training utilizes **Group Relative Policy Optimization (GRPO)** with masked importance sampling.

*   **Simultaneous Optimization:** Instead of staged training (e.g., Math stage $\to$ Coding stage), Nemotron 3 employs simultaneous training across diverse environments (Math, Code, Instruction Following, Tool Use).
*   **Reasoning Budget:** The models support inference-time compute scaling. By utilizing a specific `</think>` token, the model can dynamically extend its chain-of-thought, trading latency for higher accuracy on complex queries.

## 6. Context Extension (The "No-RoPE" Advantage)
The models support a **1M token context window**. A critical technical differentiator is the absence of Rotary Positional Embeddings (RoPE) in the attention layers.
*   **Implicit Positioning:** Because Mamba layers encode implicit positional information via their state dynamics, the sparse attention layers do not require explicit RoPE.
*   **Extrapolation:** This avoids the out-of-distribution degradation often seen when extending RoPE-based Transformers. The model demonstrates monotonic improvement in negative log-likelihood (NLL) on code sequences extending fully to 1M tokens.

# Nemotron 3 Nano

Nemotron 3 Nano is a 31.6B parameter model (3.2B active) that optimizes the inference-throughput-to-accuracy frontier. It combines the **Mamba-2** state-space model with **Transformer** attention mechanisms and **MoE** layers. The model is pretrained on 25 trillion tokens and heavily post-trained using Multi-Environment Reinforcement Learning from Verifiable Rewards (RLVR) and RLHF. It demonstrates up to $3.3\times$ higher inference throughput than similarly sized models (e.g., Qwen3-30B, GPT-OSS-20B) while achieving superior accuracy on math, coding, and agentic benchmarks.

### Architectural Details
The model architecture represents a shift toward hybrid, sparse systems to maximize token velocity without sacrificing capacity.

*   **Hybrid Composition:** The architecture integrates Mamba-2 layers for efficient sequence modeling, Grouped-Query-Attention (GQA) for focused retrieval, and MoE layers for capacity scaling.
*   **Granular MoE:** Unlike standard dense FFNs, Nemotron 3 Nano utilizes a granular MoE architecture with a learned MLP router. It features **128 total routable experts** with **6 activated per forward pass**, alongside **2 shared experts**.
*   **Parameter Efficiency:**
    *   Total Parameters: **31.6B**
    *   Active Parameters (per pass): **3.2B** (3.6B including embeddings).
    *   This sparsity allows the model to outperform 20B+ dense models while activating less than half the parameters of previous Nano generations.
*   **Layer Configuration:** It comprises 52 layers with a model dimension of 2688. The Mamba state dimension is 128, with 8 groups and 64 heads.

### Pretraining Methodology
*   **Scale and Diversity:** The model was trained on **25 trillion tokens** across 15 categories, using a "Warmup-Stable-Decay" learning rate schedule.
*   **Data Pipeline:**
    *   **Code:** Utilized a "Lynx + LLM" pipeline to render HTML and extract code/math while preserving layout, followed by synthetic generation and transpilation (e.g., Python to C++).
    *   **Synthetic Data:** Heavy use of "InfiniByte" (cross-breeding concepts from different fields) and "Reasoning Question-Answer" (RQA) datasets to enforce complex reasoning correlations.
*   **Context Extension:** A Long-Context (LC) phase employed Continuous Pretraining (CPT) with sequence lengths mixed between 512k and 4k to extend context support to **1M tokens** without degrading short-context performance.

### Post-Training Innovations
The report highlights a sophisticated post-training stack that moves beyond standard SFT.

*   **Supervised Fine-Tuning (SFT):**
    *   Implements **Reasoning Control**, allowing users to toggle reasoning on/off or set a token budget.
    *   Includes "Tool-integrated reasoning" where the model preserves reasoning tokens across multi-step agentic traces.
*   **Multi-Environment RLVR:**
    *   **Simultaneous Training:** Unlike sequential pipelines, RLVR trains on all environments (Math, Code, IF, etc.) simultaneously to prevent catastrophic forgetting.
    *   **Curriculum Learning:** Dynamically adjusts task difficulty (Gaussian sampling) to keep pass rates balanced, preventing overfitting to easy tasks.
    *   **Algorithm:** Uses synchronous **GRPO** (Group Relative Policy Optimization) with masked importance sampling.
*   **RLHF with Generative Reward Models (GenRM):**
    *   Instead of scalar rewards, a GenRM (based on Qwen3-235B) provides reasoning traces and ranking scores for responses.
    *   **Group Relative Length Control:** To combat "verbosity hacking" (where models increase length to game rewards), the team introduced a length-normalized reward adjustment. This penalizes length relative to the group mean rather than using an absolute penalty, reducing verbosity by 30% without accuracy loss.

### Quantization and Hardware Efficiency
*   **Selective FP8:** The model utilizes Post-Training Quantization (PTQ) to FP8. Crucially, a sensitivity analysis led to a **selective strategy**:
    *   **Self-attention layers (6 of 52)** and their preceding Mamba layers are kept in **BF16**.
    *   Remaining layers and KV cache are quantized to **FP8**.
*   **Throughput:** This configuration allows for massive batch sizes, achieving significantly higher throughput (up to $3.3\times$ vs Qwen3) while maintaining ~99% accuracy recovery.

### Critical Insights for the Domain Expert
1.  **The "Active Parameter" Arbitrage:** By activating only ~3.2B parameters, the model effectively competes with dense models 6-10x its active size (like GPT-OSS-20B). This validates the Hybrid Mamba-MoE approach for edge/efficient inference.
2.  **Verifiable Rewards > Human Preference:** The shift to RLVR (Reinforcement Learning from Verifiable Rewards) is a dominant theme. The model relies on unit tests (code), exact answers (math), and schema validation (JSON) to drive performance, surpassing heavily fine-tuned SFT baselines.
3.  **GenRM as the New Standard:** The use of a "Generative Reward Model" that *reasons* about response quality before scoring suggests that standard Bradley-Terry reward models are becoming obsolete for high-end reasoning tasks.
4.  **Agentic Capabilities:** The model is explicitly tuned for tool use (XML-style tags) and achieves high scores on agentic benchmarks like SWE-Bench and TauBench, positioning it as a backend for autonomous agents rather than just a chatbot.

# Nemotron-Cascade

The paper addresses the challenge of "cross-domain heterogeneity" in training general-purpose Large Language Models (LLMs). Different domains (e.g., math vs. creative writing) require vastly different verification latencies and response lengths. Instead of blending all data into a single RL stage (as done in DeepSeek-R1 or Qwen3), NVIDIA proposes **Cascade RL**: a sequential pipeline operating on disjoint domains.
*   **Key Outcome:** The Nemotron-Cascade-14B-Thinking model achieves Silver Medal performance in the IOI 2025 and outperforms its SFT teacher (DeepSeek-R1-0528) on LiveCodeBench.
*   **Model Variants:**
    1.  **Unified Model (8B):** Supports both "thinking" and "non-thinking" modes via user-controlled flags (`/think`, `/no_think`).
    2.  **Dedicated Thinking Model (14B):** Specialized for deep reasoning tasks.

### The Training Pipeline: From SFT to Cascade RL

#### Phase 1: Supervised Fine-Tuning (SFT)
The SFT stage uses a multi-stage curriculum to establish foundational skills before RL.
*   **Data Curation:** Utilizes massive synthetic data generation from DeepSeek-R1-0528 (thinking) and DeepSeek-V3 (non-thinking).
*   **Stage 1 (16K):** General, math, and code data with responses up to 16K tokens.
*   **Stage 2 (32K):** Extends context to 32K, introducing tool use and software engineering (SWE) data.
*   **Format:** For the Unified model, user prompts explicitly carry flags like `/think` or `/no_think` to trigger specific generation modes.

#### Phase 2: Cascade RL Framework
This is the core innovation. The model undergoes RL stages sequentially in the following order:
**RLHF $\rightarrow$ Instruction Following $\rightarrow$ Math $\rightarrow$ Code $\rightarrow$ SWE**.

*   **Algorithm:** Group Relative Policy Optimization (GRPO) is used throughout. It is strictly on-policy (generated data matches the policy being updated) and removes the KL divergence term, relying on group-normalized rewards.
*   **Why Cascade?** The authors argue RL is resistant to catastrophic forgetting. Unlike SFT, where new data overwrites old distributions, RL optimizes expected cumulative reward. Old capabilities (like math) persist during Code RL because the model continues to explore high-reward pathways.

### Technical Deep Dive by Domain

#### A. RLHF (Alignment)
*   **Role:** Acts as the foundation. It reduces verbosity and repetition, which surprisingly improves token efficiency for subsequent reasoning tasks.
*   **Configuration:** Uses a 72B Reward Model (RM). For the Unified model, "Half-Half" training (50% thinking prompts, 50% non-thinking) yields the best transfer and alignment across modes.
*   **Stability:** While smaller RMs (7B) require "bags of tricks" (KL penalty, reward shaping) to prevent collapse, the large 72B RM provides stable signals without these regularizations.

#### B. Instruction-Following RL (IF-RL)
*   **Problem:** Rule-based verifiers for instruction following can degrade general quality (e.g., a bad response that satisfies a length constraint gets a high reward).
*   **Solution (Unified Model):** Apply IF-RL *only* in non-thinking mode. This prevents "reward hacking" the verifier while maintaining capabilities in thinking mode.
*   **Solution (Thinking Model):** Uses a combined reward function: $R_{total} = R_{IF} + \text{sigmoid}(R_{RM})$, ensuring responses are both compliant and high-quality.

#### C. Math RL
*   **Curriculum:** Uses a "Response Length Extension" strategy: 24K (compression) $\rightarrow$ 32K (extension) $\rightarrow$ 40K (long reasoning). This stabilizes training for models that initially generate overlong, incomplete chains.
*   **Dynamic Filtering:** After each epoch, problems that are 100% solved (too easy) or 0% solved (too hard) are filtered out to maintain effective gradient signals.

#### D. Code RL
*   **Reward:** Binary execution-based reward (Pass/Fail) on unit tests.
*   **Temperature:** Higher training temperatures (e.g., 1.0) improve performance by encouraging exploration in the vast solution space of code, despite creating more unstable entropy curves compared to lower temperatures (0.6).
*   **Impact:** Code RL significantly boosts performance (e.g., LiveCodeBench) without degrading Math performance, confirming the resistance to forgetting.

#### E. Software Engineering (SWE) RL
*   **Innovation (Execution-Free Reward):** Instead of using slow Docker containers for rewards, the authors use an **LLM-based semantic similarity** metric. They compare the generated patch to a "golden patch" using a 72B judge model.
*   **Context:** Uses a retrieval-augmented approach where prompts include both ground-truth and retrieved files, trained with context lengths up to 24K-32K.

### Key Performance Insights

*   **The "Thinking" Gap:** The Unified 8B model closes the reasoning gap with dedicated thinking models. It achieves comparable performance on math/code while superior performance on instruction following (IFEval).
*   **SFT vs. RL:** The 14B model outperforms its own SFT teacher (DeepSeek-R1-0528) on LiveCodeBench (77.5% vs 74.8% on v5), proving that Cascade RL allows the student to surpass the teacher.
*   **Test-Time Scaling (IOI 2025):**
    *   The model uses a **feedback-driven pipeline**. If a submission fails, the official verdict and the incorrect code are appended to the prompt for the next generation.
    *   This "self-evolving" inference strategy allowed the 14B model to achieve a Silver Medal.

### Takeaways
1.  **Sequence Matters:** Start with generic alignment (RLHF) to fix verbosity, then move to specialized, verifiable domains (Math $\rightarrow$ Code).
2.  **Reward Modeling:** For RLHF, reward model size matters more than "tricks." A 72B RM allows for simplified RL objectives (no KL term).
3.  **Unified Architectures:** It is possible to train a single model for both instruct and reasoning tasks without performance degradation by explicitly managing training distributions (e.g., applying IF-RL only to non-thinking modes).
4.  **SWE Scalability:** Execution-based rewards are not strictly necessary for training SWE agents; semantic similarity against gold patches is a scalable proxy.
